* 基础
** 介绍
*** vuejs是什么
1. 渐进式框架，与其他大型框架不同的是，vue被设计为可以自底向上逐层应用。vue的核心库只关注图层，上手简单，整合简单，当与现代化的工具链以及各种支持类库结合使用时，vue也完全能够为复杂的单页用用提供驱动。
2. 对比react 相似之处有许多，比如virtual dom， 提供响应式和组件化的视图组件，将注意力保持在核心库，而将其他功能如陆游和全剧状态管理交给相关的库。
react比vue更好的地方，比如更丰富的生态系统。react应用中，当某个组件的状态发生变化时候，会以该组件为根，重新渲染整个组件，其他查询https://cn.vuejs.org/v2/guide/comparison.html
3. 在react中，所有的组件的渲染功能都能依靠jsx。jsx是使用xml语法编写js的一种语法糖 
*** 起步
*** 生命是渲染
*** 条件与循环
*** 处理用户输入
*** 组件化应用构建与自定义元素的关系
*** 准备好了吗
** vue实例
** 模版语法
*** 插值
**** 文本
1. 数据绑定最常见的形式就是使用双打括号法的文本插值 v-once指令的用处 - -
**** 原始HTML
双大括号会将数据解释为普通文本，而非HTML代码。为了输出真正的html，你需要使用v-html指令
1. 为了输出真正的html你需要使用v-html指令：这个span的内容将会被替换成属性值rawhtml，直接作为html--会会略解析属性之中的数据绑定。注意，你不能使用vhtml来复合局部模版，因为vue不是基于字符串的模版引擎，反之，对于用户洁面（UI），组件更适合作为可以服用和可以组合的基本单位
**** attribute
**** 使用js表达式 
1. 不应该在模版表达式中试图访问用户定义的全局变量
2. 对于所有数据绑定，vue都提供完全的js支持
3. 这些表达式会在所属的vue实例的数据作用域下作为js被解析，有个限制就是，每个绑定只能包含单个表达式，所以下面的例子都不会生效；表达式和语句，流控制和三元表达式，你想想哪些生效哪些不生效。

*** 指令
**** 参数
1. v-on
2. v-bind
**** 动态参数
我靠太科学了，对应到vue中的data属性
**** 修饰符
1. 是用.指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent修饰符告诉v-on指令对于出发的时间调用event.preventDefault();
2. 在接下来对v-on和v-for等功能的探索中，你会看到修饰福德其他例子
**** 缩写
1. v-bind
2. v-on

** 计算属性和侦听
*** 计算属性
**** 基础例子
1. 模版内的表达式非常便利，但是设计它们的初中是用于简单运算的，在模版中放入太多的逻辑会让模版锅中而且难以维护
2. 有个例子
3. 以上这个例子，模版不再是简单的声明式逻辑，对于任何复杂逻辑，你都应当使用计算属性
4. 基础例子original官网看一下
**** 计算属性缓存vs方法
1. 你可以已经注意到我们可以通过比哦啊大师中掉哦用方法来达到同样的效果：
2. 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于他们的响应式依赖进行混存的。只在相关响应式以来发生改变时他们才会重新求职。着就以为着只要message还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。
3. 这也同样意味着下面的计算属性将不再更新，因为datenow不是响应式依赖
4. 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。
5. 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性A，它需要遍历一个巨大的数组并大量的计算。然后我们可能有其他的计算属性以来A，如果没有缓存，我们将不可避免的多次执行A的getter！如果你不希望有缓存，请用方法来替代。
**** 计算属性vs侦听属性
1. vue提供了一种更通用的方式来观察和相应vue实例上的数据变动：侦听属性。当你有一些数据需要随着其他数据变动而变动时，特别是如果你之前使用过。然而，通常更好的做法是用用计算属性而不是命令式的watch回调
2.有个例子此处，上面代码是命令式且重复的，将它与计算属性的版本进行比较，计算属性好的多了，不是咩？
**** 计算属性的setter
1. 计算属性默认只有getter，不过在需要时你也可以提供一个setter：
2. computed，计算属性默认只有getter，不过在需要时你也可以提供一个setter

*** 侦听器
1.虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么vue通过watch选项提供了一个更通用的方法，来相应数据的变化。当需要在数据变化时候执行异步或开销较大的操作时，这个方式是最有用的。
例如：
** class与style绑定
** 条件渲染
** 列表渲染
*** 我们可以用v-for指令基于一个数组来渲染一个列表。v-for指令需要使用item in items形式的特殊语法，其中items是源数据数组，而item则是被迭代的数组元素的别名
*** 在v-for里面使用对象
**** 维护状态
1. 当vue正在更新使用v-for渲染的元素列表时，它默认使用就地更新的策略，如果数据项的顺序被改变，vue将不回移动dom元素来匹配数据项的顺序，而是就地更新每个元素，并且确保他们在每个索引位置正确渲染，这个类似
2. 这个默认的模式是高效的，但是只适用于不依赖自组件状态或临时dom状态，为了给vue一个提示，一遍他能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一key属性
**** 数据更新检测
1. 变异方法 一堆
2. 替换数组
3. 注意事项 修改数组长度，使用索引设置一个数组项时候
**** 对象变更检测注意事项
**** 显示过滤/排序后的结果
**** 在v-for里使用值范围
**** 在template上使用v-for
**** v-for与v-if一同使用
**** 在组件上用v-for
*** 事件处理
*** 表单输入绑定
*** 组件基础
** 事件处理
** 表单输入绑定
** 组件基础
* 深入了解组件
** 组件注册
** prop
** 自定义时间
** 插槽
** 动态组件&异步组件
** 处理边界情况
* 过渡&动画
** 进入/离开&列表过渡
** 状态过渡
* 可复用性&组合
** 混入
** 自定义指令
** 渲染函数&jsx
** 插件
** 过滤器
* 工具
** 但文件组件
** 单元测试
** ts支持
** 生产环境部署
* 规模化
** 路由
** 状态管理
** 服务端渲染
** 安全
* 内在
** 深入响应式原理
1. 当你把一个普通的js对象传入vue实例作为data选项，vue将遍历此对象所有的属性，并使用————把这些属性全部转为getter setter。————————是es5中一个无法shim的特性，这也就是vue不支持IE8以及更低版本浏览器的原因。
2. 这些getter /setter对用户来说是不可见的，到那时在内部让vue可以追踪以来，属性被访问时候和修改时候通知变更/这里需要住的是，不同浏览器在控制台打印数据对象时对getter/setter的格式化并不同，所以建议安装vue devtools来获取对检查数据更加友好的用户界面
3. 每个组件实例都对应一个watcher实例，它会在组件渲染的过程中把接触过哦的数据属性记录为依赖。之后当依赖项的setter触发时候，会通知watcher从而使它关联的组件重新渲染。
4. 对于已经创建的实例vue不允许动态添加根级别的响应式属性，但是，可以使用-----方法向嵌套对象
